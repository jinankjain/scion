package main

import (
	"encoding/binary"
	"fmt"
	"net"
	"time"

	"github.com/dchest/siphash"
	log "github.com/sirupsen/logrus"
)

type hostID = net.IP

var epoch = time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC).Unix()

// Keys used by SipHash to convert net.IP to 3 byte UIDs
const (
	key1                 = uint64(0xdeadbeef)
	key2                 = uint64(0xcafebabe)
	hostSize             = 3
	timeStampSize        = 4
	ephIDKindSize        = 1
	ctrlEphIDDuration    = time.Hour
	sessionEphIDDuration = time.Minute * 5
)

var hostIDToEphID map[string]map[string][]byte

// EphID contains 3 parts:
// host -> uid generated by SipHash
// timestamp -> expiry date associated with
// kind -> Control vs Connection EphID
type EphID struct {
	host      [hostSize]byte
	timestamp [timeStampSize]byte
	kind      byte
}

// CreateSession create a new APNA session
func CreateSession() (session *Session) {
	return &Session{}
}

func getExpTime(kind int) []byte {
	currTime := time.Now()
	switch kind {
	case SessionEphID:
		currTime.Add(sessionEphIDDuration)
	case CtrlEphID:
		currTime.Add(ctrlEphIDDuration)
	}
	timestamp := (currTime.Unix() - epoch) / 60
	bs := make([]byte, 4)
	binary.LittleEndian.PutUint32(bs, uint32(timestamp))
	return bs
}

func generateHostID(host hostID) []byte {
	uid := siphash.Hash(key1, key2, host)
	bs := make([]byte, 8)
	binary.LittleEndian.PutUint64(bs, uid)
	return bs
}

const (
	maxThreads = 4
	macOffset  = 12
)

const (
	CtrlEphID    = 0x00
	SessionEphID = 0x01
	VerifyEphID  = 0x02
	DNSRequest   = 0x03
)

func handleEphIDGeneration(kind byte, conn *net.UDPConn, retAddr *net.UDPAddr) {
	ephID := &EphID{}
	copy(ephID.host[:], generateHostID(retAddr.IP)[:hostSize])
	ephID.kind = kind
	copy(ephID.timestamp[:], getExpTime(int(kind)))
	log.WithFields(log.Fields{
		"addr":      retAddr,
		"kind":      ephID.kind,
		"hostHash":  ephID.host,
		"timestamp": ephID.timestamp,
	}).Info("EphID Generation")
	iv, encryptedEphID := encryptEphID(ephID)
	mac := computeMac(iv, encryptedEphID)
	response := append(iv, encryptedEphID...)
	response = append(response, mac...)
	if kind == CtrlEphID {
		hostIDToEphID[retAddr.Network()] = make(map[string][]byte)
		hostIDToEphID[retAddr.Network()][retAddr.String()] = response
	}
	conn.WriteToUDP(response, retAddr)
	log.WithField("response", response).Info("Final Encrypted EphID")
}

func handleEphIDVerification(buf []byte, conn *net.UDPConn, retAddr *net.UDPAddr) {
	verifyMac(buf[:macOffset], buf[macOffset:])
	decryptEphID(buf[:ivLen], buf[ivLen:macOffset])
}

func getProtocol(protocol byte) string {
	switch protocol {
	case 0x00:
		return "udp"
	default:
		panic("Unsupported Protocol")
	}
}

func handleDNSRequest(protocol string, netAddr string, conn *net.UDPConn, retAddr *net.UDPAddr) {
	log.WithFields(log.Fields{
		"protocol":       protocol,
		"server address": netAddr,
		"respone":        hostIDToEphID[protocol][netAddr],
	}).Info("EphID resolution request")
	conn.WriteToUDP(hostIDToEphID[protocol][netAddr], retAddr)
}

type ApnaConnection struct {
	serverEphID      []byte
	clientEphID      []byte
	negoiatedPrivkey string
}

func establishConnection() {
}

func handleRequest(buf []byte, conn *net.UDPConn, retAddr *net.UDPAddr) (ephID *EphID) {
	switch buf[0] {
	case CtrlEphID:
		handleEphIDGeneration(CtrlEphID, conn, retAddr)
	case SessionEphID:
		handleEphIDGeneration(SessionEphID, conn, retAddr)
	case VerifyEphID:
		//TODO(jinankjain): check buffer bound
		handleEphIDVerification(buf[1:], conn, retAddr)
	case DNSRequest:
		handleDNSRequest(getProtocol(buf[1]), string(buf[2:]), conn, retAddr)
	}
	return
}

func handleConnection(serverConn *net.UDPConn, quit chan struct{}) {
	for {
		buf := make([]byte, 2048)
		n, addr, err := serverConn.ReadFromUDP(buf)
		if err != nil {
			log.WithField("err", err).Error("Read Failed")
			quit <- struct{}{}
		} else {
			handleRequest(buf[0:n], serverConn, addr)
			log.WithFields(log.Fields{
				"data": string(buf[0:n]),
				"addr": addr,
			}).Info("Received information")
		}
	}
}

// RunServer runs apna session manager
func RunServer(port int) error {
	hostIDToEphID = make(map[string]map[string][]byte)
	serverAddr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%v", port))
	if err != nil {
		return err
	}
	serverConn, err := net.ListenUDP("udp", serverAddr)
	if err != nil {
		return err
	}
	log.Infof("Started apna session manager on port %v", port)
	quit := make(chan struct{})
	for i := 0; i < maxThreads; i++ {
		go handleConnection(serverConn, quit)
	}
	<-quit
	return nil
}
